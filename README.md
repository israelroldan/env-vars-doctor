# env-vars-doctor

Environment variable management for projects and monorepos - sync, validate, and diagnose `.env` files.

## Features

- **Schema-based validation** - Define environment variables with directives in `.env.local.example` files
- **Works everywhere** - Supports both single projects and monorepos with multiple workspaces
- **Interactive prompts** - Guided setup for missing values
- **Source code scanning** - Detect undocumented `process.env` usage
- **CI integration** - Validate environment completeness in pipelines
- **Plugin architecture** - Extend with custom value sources and integrations

## Installation

```bash
npm install env-vars-doctor
# or
pnpm add env-vars-doctor
# or
yarn add env-vars-doctor
```

Add a `postinstall` hook so env-vars-doctor runs automatically after every install:

```json
{
  "scripts": {
    "env-vars-doctor": "env-vars-doctor",
    "postinstall": "env-vars-doctor postinstall"
  }
}
```

## Quick Start

1. Create a `.env.local.example` file in your project root (see [Example Schema](#example-schema) below):

```bash
# [required] [prompt] Database connection string
DATABASE_URL=

# [optional] [default:3000] Server port
PORT=3000

# [required] [boolean] Enable debug mode
DEBUG=false
```

2. Run the interactive setup. With no subcommand, env-vars-doctor runs an interactive sync — it walks through each missing variable and prompts for values:

```bash
npx env-vars-doctor               # Interactive sync (all apps)
npx env-vars-doctor --app=web     # Sync a specific app only
```

3. Add the `postinstall` hook (see [Installation](#installation)) so new team members get prompted automatically after `npm install`.

4. Check status or diagnose issues anytime:

```bash
npx env-vars-doctor status        # Show what's missing
npx env-vars-doctor diagnose      # Find process.env usage with no schema entry
```

## Schema Directives

Add directives in comments above variables:

| Directive | Description |
|-----------|-------------|
| `[required]` | Variable must have a value |
| `[optional]` | Variable can be empty |
| `[prompt]` | Interactively prompt for value |
| `[default:value]` | Use default if not set |
| `[boolean]` | Yes/no prompt (true/false) |
| `[boolean:yes/no]` | Boolean with custom values |
| `[copy:VAR]` | Copy value from another variable |
| `[computed]` | Use the example value as a computed fallback |
| `[placeholder]` | Use the example value as-is (default when no directive matches) |
| `[local-only]` | Skip in CI/deployment contexts |

Plugins can register additional directives (e.g., `[supabase]` from the built-in Supabase plugin). See [Plugins](#plugins) for details.

### Directive Combinations

Common patterns for combining directives:

| Pattern | Use case | Example |
|---------|----------|---------|
| `[required] [prompt]` | Secrets the user must provide | `WORKOS_API_KEY=` |
| `[required] [supabase]` | Auto-fetched from local Supabase (plugin) | `SUPABASE_SERVICE_ROLE_KEY=` |
| `[required] [default:X]` | Required with sensible local default | `SUPABASE_URL=http://127.0.0.1:54321` |
| `[optional] [prompt]` | Optional API key, prompt if wanted | `GROQ_API_KEY=` |
| `[optional] [default:X]` | Config with default, no prompt | `GROQ_MODEL=llama-3.1-8b-instant` |
| `[optional] [boolean]` | Feature toggle | `LANGSMITH_TRACING=false` |
| `[optional] [placeholder]` | Use the example value verbatim | `APP_NAME=my-app` |
| `[optional] [computed]` | Evaluated fallback (falls back to example value) | `PORT=3000` |

`[placeholder]` copies the example value as-is. `[computed]` is intended for values that could be generated by a plugin or custom logic, falling back to the example value when no computation is available.

### Example Schema (Monorepo)

In a monorepo, the root schema holds shared variables and each app adds its own:

**Root `.env.local.example`** — shared across all apps:

```bash
# =============================================================================
# Database (Supabase)
# =============================================================================

# [required] [default:http://127.0.0.1:54321] Local Supabase URL
SUPABASE_URL=http://127.0.0.1:54321

# [required] [supabase] Supabase anonymous key
NEXT_PUBLIC_SUPABASE_ANON_KEY=

# [required] [supabase] Supabase service role key
SUPABASE_SERVICE_ROLE_KEY=

# =============================================================================
# Authentication
# =============================================================================

# [required] [prompt] WorkOS API key
WORKOS_API_KEY=

# [required] [prompt] WorkOS client ID
WORKOS_CLIENT_ID=

# =============================================================================
# AI / Optional Services
# =============================================================================

# [optional] [prompt] Groq API key for LLM inference
GROQ_API_KEY=

# [optional] [default:llama-3.1-8b-instant] Groq model to use
GROQ_MODEL=llama-3.1-8b-instant

# [optional] [boolean] Enable LangSmith tracing
LANGSMITH_TRACING=false

# =============================================================================
# Development
# =============================================================================

# [local-only] [default:true] Hot reload in development
HOT_RELOAD=true
```

**`apps/web/.env.local.example`** — app-specific variables:

```bash
# App-specific variables for web.
# Shared variables (database, auth, AI) are defined in the root .env.local.example.

# [required] [default:3000] Web app port
PORT=3000

# [optional] [prompt] Analytics write key
NEXT_PUBLIC_ANALYTICS_KEY=
```

## Monorepo Variable Model

env-vars-doctor uses a two-tier variable model (illustrated in the [Example Schema](#example-schema-monorepo) above):

- **Root `.env.local.example`** — Shared variables inherited by all apps in the monorepo
- **`apps/X/.env.local.example`** — App-specific variables for each workspace

During `sync`, each app receives a merged view: shared variables + its own app-specific variables. App-specific definitions override shared ones with the same name.

At deploy time (with the Vercel plugin), shared variables are pushed to the Vercel team level, while app-specific variables go to the corresponding Vercel project.

## Commands

### `sync` (default)

Create or update `.env.local` files from schema. This is the default command — running `env-vars-doctor` with no subcommand is equivalent to `env-vars-doctor sync`.

```bash
env-vars-doctor                       # Sync (default command)
env-vars-doctor sync --app=web        # Sync a specific app
env-vars-doctor sync --all            # Sync all workspaces
env-vars-doctor sync --force          # Overwrite existing values
```

### `status`

Show environment variable status:

```bash
env-vars-doctor status                # Current app status
env-vars-doctor status --app=web      # Specific app
env-vars-doctor status --all          # All workspaces
```

### `check`

Validate environment without prompts:

```bash
env-vars-doctor check             # Exit 1 if issues found
env-vars-doctor check --ci        # CI-optimized output
```

### `diagnose`

Scan source code for `process.env` usage and cross-reference against your schema. Reports two categories:

- **Missing from schema** — Variables used in code (e.g., `process.env.SECRET_FLAG`) that have no entry in any `.env.local.example`. These are undocumented and will be invisible to `sync` and `ci`.
- **Potentially unused** — Variables defined in the schema but never referenced in source code.

```bash
env-vars-doctor diagnose              # Scan all apps and packages
env-vars-doctor diagnose --app=web    # Scan a specific app
env-vars-doctor diagnose --fix        # Auto-add missing vars to the appropriate schema file
env-vars-doctor diagnose --verbose    # Show file locations of each usage
```

### `clean`

Remove generated `.env.local` files:

```bash
env-vars-doctor clean             # Current app
env-vars-doctor clean --all       # All workspaces
```

### `export`

Export variables for deployment:

```bash
env-vars-doctor export --format=json     # JSON format (default)
env-vars-doctor export --format=vercel   # Vercel format
env-vars-doctor export --format=shell    # Shell export format
env-vars-doctor export --format=values   # Simple key=value pairs
```

### `postinstall`

Run after `npm/pnpm install`. In CI, it validates required variables against `process.env` (exits 1 if missing). Locally, it shows a status summary and never fails.

```bash
env-vars-doctor postinstall
```

### `ci`

Validate environment in CI pipelines. Checks `process.env` (not `.env.local`), and skips `[local-only]` and `[prompt]` directives.

```bash
env-vars-doctor ci                # Validate all apps
env-vars-doctor ci --app=web      # Validate a specific app
```

### `deploy`

Push environment variables to deployment platforms (Vercel). Requires `VERCEL_TOKEN` and `VERCEL_TEAM_ID`.

```bash
env-vars-doctor deploy                     # Deploy all
env-vars-doctor deploy --target=production # Production only
env-vars-doctor deploy --dry-run           # Preview changes
```

How deploy works:

- **Two entries per variable** — each var needs a `production` entry and a non-production entry (`preview` + `development` + custom environments)
- **Detects gaps** — finds missing variables and variables missing one of the two target entries
- **Non-production values** come from your local `.env.local`
- **Production values** are prompted interactively (since they often differ from local, e.g., a production database URL)

## Configuration

Create a config file in your project root. Supported formats: `env-vars-doctor.config.ts`, `.js`, `.cjs`, `.mjs`, `.mts`, `.cts`, `.env-vars-doctorrc`, `.env-vars-doctorrc.json`, `.env-vars-doctorrc.yaml`, `.env-vars-doctorrc.yml`, or a `"env-vars-doctor"` field in `package.json`.

```typescript
import { defineConfig } from 'env-vars-doctor'

export default defineConfig({
  project: {
    rootEnvExample: '.env.local.example',
    rootEnvLocal: '.env.local',
    workspaces: {
      detection: 'pnpm',  // 'auto' | 'pnpm' | 'npm' | 'yarn' | 'manual'
      patterns: ['apps/*', 'packages/*'],
      sourceDir: 'src',   // Directory to scan for process.env usage (diagnose command)
    },
  },
  scanning: {
    extensions: ['.ts', '.tsx', '.js', '.jsx'],
    skipDirs: ['node_modules', 'dist', '.next'],
    ignoreMissing: ['NODE_ENV', 'CI', 'VERCEL'],  // Platform-provided vars that don't need a schema entry
    ignoreUnused: ['LANGSMITH_TRACING'],           // Vars read by SDKs internally, not in your source code
  },
  ci: {
    skipEnvVar: 'SKIP_ENV_DOCTOR',
    skipDirectives: ['local-only', 'prompt'],
    detection: {
      ci: ['CI', 'CONTINUOUS_INTEGRATION'],
      github: ['GITHUB_ACTIONS'],
      vercel: ['VERCEL'],
      netlify: ['NETLIFY'],
    },
  },
})
```

## Plugins

### Built-in Plugins

#### Supabase Plugin

Auto-fetch keys from local Supabase:

```typescript
import { defineConfig } from 'env-vars-doctor'

export default defineConfig({
  plugins: {
    supabase: {
      enabled: true,
      databaseDir: 'packages/database',
      variableMapping: {
        'NEXT_PUBLIC_SUPABASE_ANON_KEY': 'anon_key',
        'SUPABASE_SERVICE_ROLE_KEY': 'service_role_key',
      },
    },
  },
})
```

Then use in schema:

```bash
# [required] [supabase] Supabase anon key
NEXT_PUBLIC_SUPABASE_ANON_KEY=
```

#### Vercel Plugin

Deploy environment variables to Vercel:

```typescript
import { defineConfig } from 'env-vars-doctor'

export default defineConfig({
  plugins: {
    vercel: {
      enabled: true,
      projectMapping: {
        'web': 'my-web-project',
        'api': 'my-api-project',
      },
    },
  },
})
```

```bash
env-vars-doctor deploy --target=production
```

### Custom Plugins

Create custom value sources:

```typescript
import type { EnvDoctorPlugin, ValueSourceProvider } from 'env-vars-doctor/plugins'

const myPlugin: EnvDoctorPlugin = {
  meta: {
    name: 'my-plugin',
    version: '1.0.0',
  },
  sources: [
    {
      directiveType: 'vault',
      pattern: /\[vault(?::([^\]]+))?\]/i,
      resolve: async (definition, context) => {
        const secret = await fetchFromVault(definition.key)
        return { value: secret, source: 'vault' }
      },
      isAvailable: () => !!process.env.VAULT_TOKEN,
      unavailableMessage: 'Vault token not configured',
    },
  ],
}

export default myPlugin
```

### Plugin Interfaces

Plugins can provide multiple extension points via the `EnvDoctorPlugin` interface:

**`ValueSourceProvider`** — Handle custom directives for resolving variable values:
```typescript
{
  directiveType: string
  pattern: RegExp
  resolve: (definition: EnvVarDefinition, context: ResolverContext) => Promise<ResolvedValue>
  isAvailable?: (context: ResolverContext) => boolean | Promise<boolean>
  unavailableMessage?: string
}
```

**`DeploymentProvider`** — Add deployment targets beyond Vercel:
```typescript
{
  name: string
  getTargets: (app: AppInfo, context: ResolverContext) => Promise<DeploymentTarget[]>
  deploy: (app: AppInfo, variables: Map<string, string>, target: DeploymentTarget, context: ResolverContext) => Promise<{ success: boolean; message: string }>
  isAvailable?: (context: ResolverContext) => boolean | Promise<boolean>
  unavailableMessage?: string
}
```

**`CommandProvider`** — Register custom CLI commands:
```typescript
{
  name: string
  description: string
  usage?: string
  handler: (args: string[], context: ResolverContext) => Promise<number>
}
```

**`PluginHooks`** — Lifecycle hooks for plugins:
```typescript
{
  onInit?: (config: EnvDoctorConfig) => Promise<void> | void
  beforeSync?: (apps: AppInfo[]) => Promise<void> | void
  afterSync?: (results: ReconciliationResult[]) => Promise<void> | void
  beforeResolve?: (definition: EnvVarDefinition, context: ResolverContext) => Promise<void> | void
  afterResolve?: (definition: EnvVarDefinition, result: ResolvedValue, context: ResolverContext) => Promise<void> | void
}
```

## Programmatic API

```typescript
import { EnvDoctor, loadConfig } from 'env-vars-doctor'

const config = await loadConfig()
const doctor = new EnvDoctor(config)

// Parse schema
const schema = await doctor.parseSchema('.env.local.example')

// Scan workspaces
const apps = await doctor.scanWorkspaces()

// Reconcile differences
const diff = await doctor.reconcile(schema, currentEnv)

// Generate report
const report = doctor.report(diff)
```

## CI Integration

### GitHub Actions

```yaml
- name: Validate environment
  run: npx env-vars-doctor check --ci
  env:
    CI: true
```

### Skip in CI

Set `SKIP_ENV_DOCTOR=1` to skip validation:

```yaml
env:
  SKIP_ENV_DOCTOR: 1
```

## Environment Variables

These environment variables affect env-vars-doctor itself:

| Variable | Description |
|----------|-------------|
| `VERCEL_TOKEN` | Required for the `deploy` command |
| `VERCEL_TEAM_ID` | Required for the `deploy` command |
| `SKIP_ENV_DOCTOR` | Skip all validation (configurable name via `ci.skipEnvVar` in config) |

## License

MIT
